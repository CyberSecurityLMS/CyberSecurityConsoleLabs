# Уязвимость 10: Гонки состояний (Race Conditions)

Это задание демонстрирует уязвимость типа "гонка состояний", в частности, "Время проверки к времени использования" (TOCTOU - Time-of-Check to Time-of-Use). Такая уязвимость возникает в многопоточных или многопроцессных средах, когда результат проверки состояния ресурса (например, файла) может стать неактуальным к моменту использования этого ресурса из-за действий другого потока/процесса.

## Файлы

*   `vulnerable_app.py`: Уязвимое приложение, которое запускает несколько потоков. Каждый поток проверяет существование файла (`os.path.exists`), ждет некоторое время, а затем пытается записать в файл (`open(..., 'a')`). Если внешний процесс (или другой поток) удалит файл между проверкой и записью, возникнет ошибка `FileNotFoundError`.
*   `fixed_app.py`: Исправленное приложение, использующее блокировку (`threading.Lock`) для синхронизации доступа к файлу. Критическая секция кода (доступ к файлу) выполняется только одним потоком в каждый момент времени, предотвращая гонку.

## Описание уязвимости

В `vulnerable_app.py` каждый поток выполняет следующую последовательность:

```python
# vulnerable_app.py
# 1. Проверка (Time-of-Check)
file_exists = os.path.exists(FILENAME)

if file_exists:
    time.sleep(ACTION_DELAY_SECONDS) # Пауза

    # 2. Действие (Time-of-Use)
    try:
        # Уязвимый момент: файл мог быть удален здесь
        with open(FILENAME, "a") as f:
            f.write(...)
    except FileNotFoundError:
        print("... ОШИБКА: Файл не найден во время записи! (Race Condition)")
```

Проблема возникает из-за промежутка времени (`time.sleep`) между проверкой `os.path.exists()` и попыткой `open()`. Если несколько потоков выполняют этот код параллельно, и внешний фактор (другой процесс, или мы можем раскомментировать строку `cleanup()` в `vulnerable_app.py` для имитации) удалит файл `FILENAME` *после* того, как поток проверил его существование, но *до* того, как он попытался его открыть для записи, операция `open()` вызовет исключение `FileNotFoundError`.

## Эксплуатация

Гонки состояний сложно надежно воспроизвести, так как они зависят от планировщика потоков ОС и точного тайминга.

1.  **Запустите уязвимое приложение несколько раз:**
    ```bash
    python vulnerable_app.py
    python vulnerable_app.py 5 # С 5 потоками
    ```
    Вы можете увидеть нормальное выполнение, где все потоки успешно записывают в файл.

2.  **Попытка вызвать гонку (может не сработать с первого раза):**
    *   Раскомментируйте строки с имитацией удаления файла в `vulnerable_app.py`:
        ```python
        # vulnerable_app.py
        # ...
        # Раскомментируйте строки ниже:
        time.sleep(ACTION_DELAY_SECONDS / 2)
        print("\n[ИМИТАЦИЯ] ВНЕШНЕЕ УДАЛЕНИЕ ФАЙЛА!\n")
        cleanup() # Теперь файл удаляется во время работы потоков
        # ...
        ```
    *   Запустите измененный `vulnerable_app.py`:
        ```bash
        python vulnerable_app.py 5
        ```
    С большой вероятностью вы увидите, что некоторые потоки выведут ошибку: `ОШИБКА: Файл 'shared_resource.txt' не найден во время записи! (Race Condition)`. Это происходит потому, что эти потоки успели проверить существование файла, но к моменту записи файл был удален основным потоком.

## Исправление

Гонки состояний предотвращаются с помощью механизмов синхронизации, которые гарантируют, что доступ к общему ресурсу (в данном случае, файлу) является атомарным или происходит в рамках критической секции.

В `fixed_app.py` используется `threading.Lock`:

1.  **Создание блокировки:** Создается один объект `threading.Lock()`, который будет использоваться всеми потоками.
2.  **Захват и освобождение:** Каждый поток перед доступом к файлу пытается захватить блокировку с помощью `with file_lock:`. Оператор `with` гарантирует, что блокировка будет освобождена автоматически, даже если внутри блока возникнет исключение.
3.  **Критическая секция:** Код внутри блока `with file_lock:` может выполняться только одним потоком одновременно. Это означает, что проверка файла (если бы она была нужна внутри) и его использование происходят без прерываний со стороны других потоков, обращающихся к *этому же* ресурсу через *эту же* блокировку.

```python
# fixed_app.py
import threading

file_lock = threading.Lock()

def perform_action_safe(thread_id):
    with file_lock: # Захват блокировки
        # --- Начало критической секции ---
        print(f"[Поток {thread_id}] Блокировка получена...")
        try:
            # Атомарная операция или безопасная последовательность
            with open(FILENAME, "a") as f: # 'a' создает файл, если его нет
                f.write(...)
            print(f"[Поток {thread_id}] Запись успешна.")
        except Exception as e:
             print(f"[Поток {thread_id}] Ошибка записи: {e}")
        # --- Конец критической секции ---
    # Блокировка автоматически освобождается здесь
```
В данном конкретном случае использование режима `'a'` (append) для `open()` само по себе является достаточно атомарным для предотвращения `FileNotFoundError`, так как оно создает файл при необходимости. Блокировка здесь добавлена для демонстрации общего принципа синхронизации и защиты более сложных операций с файлом.

## Проверка исправления

1.  **Запустите исправленное приложение:**
    ```bash
    python fixed_app.py 5
    ```
    Вы увидите, что потоки выполняются последовательно (в части доступа к файлу из-за блокировки) и все успешно записывают в файл `shared_resource_fixed.txt`. Ошибок `FileNotFoundError`, связанных с гонкой, не будет. Вывод покажет содержимое файла со всеми записями. 