# Уязвимость 9: Обход аутентификации (Authentication Bypass)

Это задание демонстрирует уязвимость обхода аутентификации, которая возникает из-за ошибок в логике проверки учетных данных пользователя. Это может позволить злоумышленнику получить доступ к системе или ее частям без ввода правильного пароля или даже от имени несуществующего пользователя.

## Файлы

*   `vulnerable_app.py`: Уязвимое приложение, где функция входа `login_vulnerable` неправильно обрабатывает случай несуществующего пользователя, возвращая `{}`, а функция доступа `access_sensitive_data` нестрого проверяет результат входа (считает `{}` за успех при проверке `is not None`).
*   `fixed_app.py`: Исправленное приложение, где функция входа `login_secure` всегда возвращает `None` при любой ошибке, а функция доступа `access_sensitive_data_secure` строго проверяет, что результат входа - это непустой словарь с ожидаемыми данными.

## Описание уязвимости

Уязвимость в `vulnerable_app.py` состоит из двух частей:

1.  **Ошибка в `login_vulnerable`:** Если пользователь не найден, функция возвращает пустой словарь `{}` вместо явного признака неудачи, такого как `None`.
    ```python
    # vulnerable_app.py
    def login_vulnerable(username, password):
        # ...
        if not user_data: # Пользователь не найден
            print("...возвращаем {} для имитации обхода аутентификации!")
            return {} # !!! УЯЗВИМОСТЬ !!!
        # ...
    ```
2.  **Нестрогая проверка результата в `access_sensitive_data`:** Функция, предоставляющая доступ, проверяет результат логина с помощью `if logged_in_user_data is not None:`. Эта проверка истинна для пустого словаря `{}`, возвращаемого при ошибке в `login_vulnerable`.
    ```python
    # vulnerable_app.py (с исправленной демонстрацией в README)
    def access_sensitive_data(logged_in_user_data):
        print(f"\nПроверка результата аутентификации: {logged_in_user_data}")
        # !!! УЯЗВИМОСТЬ В ПРОВЕРКЕ !!! 'is not None' истинно для {}
        if logged_in_user_data is not None:
            print("Проверка 'if logged_in_user_data is not None' пройдена.")
            secret = logged_in_user_data.get('data', '[ДАННЫЕ НЕ ПОЛУЧЕНЫ, НО ДОСТУП РАЗРЕШЕН!]')
            # ... доступ разрешен ...
        else:
             # ... доступ запрещен (только если login вернул None) ...
    ```
Это позволяет злоумышленнику, введя имя несуществующего пользователя, обойти проверку пароля и получить доступ к функции `access_sensitive_data`.

## Эксплуатация

*Примечание: Для демонстрации эксплуатации убедитесь, что в `vulnerable_app.py` проверка в `access_sensitive_data` именно `if logged_in_user_data is not None:`, а не `if logged_in_user_data:`.* 

1.  **Попробуйте успешный вход:**
    ```bash
    python vulnerable_app.py root root_password
    ```
    Вы увидите успешный вход и доступ к "Super sensitive data".

2.  **Попробуйте вход с неверным паролем:**
    ```bash
    python vulnerable_app.py root wrongpassword
    ```
    Вы увидите сообщение "Неверный пароль." и "Доступ запрещен."

3.  **Выполните обход аутентификации:**
    Введите имя несуществующего пользователя и любой пароль:
    ```bash
    python vulnerable_app.py non_existent_user foobar
    ```
    Вы увидите:
    *   `Пользователь 'non_existent_user' не найден...`
    *   `...возвращаем {} для имитации обхода аутентификации!`
    *   `Проверка 'if logged_in_user_data is not None' пройдена.`
    *   `--- Доступ к 'защищенной' области разрешен ---`
    *   `Секретные данные: [ДАННЫЕ НЕ ПОЛУЧЕНЫ, НО ДОСТУП РАЗРЕШЕН!]`
    Доступ к защищенной области получен без валидной аутентификации.

## Исправление

Уязвимость устранена в `fixed_app.py` двумя ключевыми изменениями:

1.  **`login_secure` возвращает `None`:** Функция входа теперь всегда возвращает `None` при любой неудаче (пользователь не найден ИЛИ пароль неверный).
    ```python
    # fixed_app.py
    def login_secure(username, password):
        # ...
        if not user_data:
            return None # Явная неудача
        # ...
        if user_data['password'] != password:
             return None # Явная неудача
        return user_data # Успех
    ```
2.  **Строгая проверка в `access_sensitive_data_secure`:** Функция доступа теперь не просто проверяет, что результат не `None`, а убеждается, что это *словарь*, и он *содержит ожидаемые данные* (проверка `logged_in_user_data.get('data') is not None`).
    ```python
    # fixed_app.py
    def access_sensitive_data_secure(logged_in_user_data):
        # ...
        # Строгая проверка: это словарь И он содержит ключ 'data'
        if isinstance(logged_in_user_data, dict) and logged_in_user_data.get('data') is not None:
            print("Проверка аутентификации пройдена...")
            # ... доступ разрешен ...
        else:
            print("Проверка аутентификации НЕ пройдена.")
            print("Доступ запрещен.")
    ```
Таким образом, даже если бы `login_secure` по ошибке вернула `{}`, проверка в `access_sensitive_data_secure` все равно бы не прошла.

## Проверка исправления

1.  **Попробуйте успешный вход:**
    ```bash
    python fixed_app.py root root_password
    ```
    Вы увидите успешный вход и доступ к данным.

2.  **Попробуйте вход с неверным паролем:**
    ```bash
    python fixed_app.py root wrongpassword
    ```
    Вы увидите сообщение "Неверный пароль." и "Доступ запрещен."

3.  **Попробуйте обход с несуществующим пользователем:**
    ```bash
    python fixed_app.py non_existent_user foobar
    ```
    Вы увидите сообщение "Пользователь 'non_existent_user' не найден." и "Доступ запрещен." Обход аутентификации не удался. Исправление работает. 