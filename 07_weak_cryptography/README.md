# Уязвимость 7: Некорректная/Слабая криптография (Weak/Broken Cryptography)

Это задание демонстрирует риски использования слабых, устаревших или неправильно реализованных криптографических алгоритмов для защиты данных.

## Файлы

*   `vulnerable_app.py`: Уязвимое приложение, использующее очень слабый шифр Цезаря с фиксированным ключом (сдвигом) для "шифрования" данных.
*   `fixed_app.py`: Исправленное приложение, использующее современный, сильный алгоритм аутентифицированного шифрования AES-GCM из библиотеки `cryptography`.
*   `requirements.txt`: Содержит зависимость `cryptography` для `fixed_app.py`.

## Описание уязвимости

В `vulnerable_app.py` для шифрования используется шифр Цезаря - простой сдвиг букв алфавита на фиксированное число позиций (`FIXED_SHIFT = 3`).

```python
# vulnerable_app.py
FIXED_SHIFT = 3

def caesar_cipher_encrypt(plaintext, shift):
    # ... реализация сдвига ...

encrypted_data = caesar_cipher_encrypt(secret_data, FIXED_SHIFT)
encoded_data = base64.b64encode(encrypted_data.encode()).decode() # Base64 для маскировки
```
Проблемы этого подхода:
1.  **Алгоритм тривиален:** Шифр Цезаря известен тысячи лет и легко взламывается перебором (всего 25 возможных сдвигов для английского алфавита) или частотным анализом.
2.  **Ключ фиксирован и известен:** Сдвиг `3` зашит прямо в коде. Любой, кто видит код, знает ключ.
3.  **Отсутствие аутентификации:** Шифр не предоставляет никакой защиты от изменения зашифрованных данных (нет проверки целостности).
4.  **Base64 - не шифрование:** Кодирование в Base64 просто представляет бинарные данные в текстовом виде, оно легко обратимо (`base64.b64decode`) и не добавляет безопасности.

Любой, кто получит "зашифрованные" данные (`encoded_data`), сможет легко их расшифровать, даже не зная исходного кода, просто попробовав все возможные сдвиги.

## Эксплуатация

1.  **Запустите уязвимое приложение:**
    ```bash
    python vulnerable_app.py "VerySecret123!"
    ```
    Приложение выведет "зашифрованные" данные в Base64, например: `Vmhuwvhfuhw123!` -> `Vmh1d2hoZnVocjEyMyE=`

2.  **Ручная расшифровка:**
    *   Скопируйте Base64 строку (например, `Vmh1d2hoZnVocjEyMyE=`).
    *   Декодируйте ее из Base64 (можно использовать онлайн-декодер или Python: `base64.b64decode('Vmh1d2hoZnVocjEyMyE=').decode()`). Получим `Vmhuwvhfuhw123!`.
    *   Примените обратный сдвиг (-3) к буквам: V->S, m->j, h->e, u->r, w->t... Получится "VerySecret123!". Уязвимость очевидна.

## Исправление

**Никогда не используйте слабые или самодельные алгоритмы шифрования! Используйте проверенные, стандартные криптографические библиотеки и алгоритмы.**

В `fixed_app.py` применены современные практики:

1.  **Сильный алгоритм:** Используется AES (Advanced Encryption Standard) – современный стандарт симметричного шифрования. Выбрана длина ключа 256 бит.
2.  **Аутентифицированное шифрование (AEAD):** Используется режим AES-GCM (Galois/Counter Mode). Он не только шифрует данные, но и обеспечивает их **целостность и аутентичность**. Это значит, что если зашифрованные данные будут изменены, попытка расшифровки вызовет ошибку.
3.  **Производный ключ (Key Derivation):** Ключ шифрования не хранится напрямую, а генерируется из пароля пользователя с помощью функции **PBKDF2** (Password-Based Key Derivation Function 2). Это стандартный способ получения криптографического ключа из менее случайного источника (пароля).
    *   **Соль (Salt):** Используется соль (`FIXED_SALT`) при генерации ключа. Соль делает атаку по радужным таблицам неэффективной. **Важно:** В реальном приложении соль должна быть уникальной для каждого пароля/ключа и храниться вместе с зашифрованными данными. Здесь для простоты она фиксирована.
    *   **Итерации:** PBKDF2 выполняет множество итераций (здесь 100 000), чтобы замедлить атаки перебором пароля.
4.  **Уникальный Nonce:** Для каждого шифрования AES-GCM генерируется уникальный случайный `nonce` (number used once). Nonce не секретен и хранится вместе с шифротекстом. Повторное использование nonce с тем же ключом катастрофически снижает безопасность GCM.

```python
# fixed_app.py
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
# ...

# Генерация ключа из пароля
key = derive_key(password_bytes, salt)
# Шифрование AES-GCM
nonce = os.urandom(12)
encrypted_data = AESGCM(key).encrypt(nonce, data, None)
# Расшифровка AES-GCM
decrypted_data = AESGCM(key).decrypt(nonce, encrypted_data, None)
```

## Проверка исправления

1.  **Установите зависимость:**
    ```bash
    pip install -r requirements.txt
    ```
2.  **Запустите исправленное приложение с секретом и паролем:**
    ```bash
    python fixed_app.py "VerySecret123!" "mySecurePassword"
    ```
    Вы увидите зашифрованные данные в Base64 (они будут отличаться при каждом запуске из-за случайного nonce) и сообщение об успешном восстановлении.

3.  **Попытайтесь расшифровать с неверным паролем:**
    Запуск `load_secret_secure` в конце скрипта имитирует это. Вы увидите сообщение об ошибке расшифровки (например, `Ошибка расшифровки AES-GCM: InvalidTag`). Режим GCM обнаружил, что данные не могут быть расшифрованы с ключом, полученным из неверного пароля (или что данные были повреждены). Исправление работает. 